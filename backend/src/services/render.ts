import { Resvg } from "@resvg/resvg-js";

export type Puzzle = {
  title?: string;
  fen: string;
  bestMove?: string;
  description?: string;
};

export type RenderMeta = {
  username?: string;
  tagline?: string;
};

function escapeHtml(text: string): string {
  return (text || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

// Unicode chess pieces (works without external assets)
const PIECE_UNICODE: Record<string, string> = {
  K: "♔",
  Q: "♕",
  R: "♖",
  B: "♗",
  N: "♘",
  P: "♙",
  k: "♚",
  q: "♛",
  r: "♜",
  b: "♝",
  n: "♞",
  p: "♟",
};

function fenToBoard(fen: string): (string | null)[][] {
  const placement = (fen || "").split(" ")[0] || "";
  const rows = placement.split("/");
  if (rows.length !== 8) throw new Error("Invalid FEN (rows != 8)");

  const board: (string | null)[][] = Array.from({ length: 8 }, () => Array(8).fill(null));

  for (let r = 0; r < 8; r++) {
    const row = rows[r];
    let file = 0;
    for (const ch of row) {
      if (/\d/.test(ch)) {
        file += Number(ch);
      } else {
        if (file > 7) throw new Error("Invalid FEN (file overflow)");
        board[r][file] = ch;
        file += 1;
      }
    }
    if (file !== 8) throw new Error("Invalid FEN (file != 8)");
  }

  return board;
}

export async function generateDesign(puzzle: Puzzle, meta: RenderMeta = {}) {
  const width = 1200;
  const height = 1600;

  const username = meta.username ? `@${meta.username}` : "@chess-tee";
  const tagline = meta.tagline || "Choose the moment to print";

  // Layout
  const pad = 80;
  const headerY = 110;

  const boardSize = 720; // square
  const boardX = pad;
  const boardY = 320;

  const square = boardSize / 8;

  // Colors (simple for now)
  const light = "#f4f4f4";
  const dark = "#0f172a"; // deep navy
  const textMain = "#111";
  const textSub = "#444";

  const lines: string[] = [];

  // Header
  lines.push(
    `<text x="${pad}" y="${headerY}" font-size="60" font-family="Arial" font-weight="800" fill="${textMain}">
      ${escapeHtml(username)}
    </text>`
  );
  lines.push(
    `<text x="${pad}" y="${headerY + 44}" font-size="26" font-family="Arial" fill="${textSub}">
      ${escapeHtml(tagline)}
    </text>`
  );
  lines.push(
    `<text x="${pad}" y="${headerY + 92}" font-size="34" font-family="Arial" font-weight="800" fill="${textMain}">
      ${escapeHtml(puzzle.title || "Best moment")}
    </text>`
  );

  if (puzzle.bestMove) {
    lines.push(
      `<text x="${pad}" y="${headerY + 130}" font-size="24" font-family="Arial" fill="${textSub}">
        Best move: ${escapeHtml(puzzle.bestMove)}
      </text>`
    );
  }

  // Divider
  lines.push(
    `<line x1="${pad}" y1="260" x2="${width - pad}" y2="260" stroke="#ddd" stroke-width="2" />`
  );

  // Board background
  lines.push(
    `<rect x="${boardX}" y="${boardY}" width="${boardSize}" height="${boardSize}" rx="8" fill="#ffffff" stroke="#e5e7eb" />`
  );

  // Squares
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const x = boardX + c * square;
      const y = boardY + r * square;
      const isDark = (r + c) % 2 === 1;
      lines.push(
        `<rect x="${x}" y="${y}" width="${square}" height="${square}" fill="${isDark ? dark : light}" />`
      );
    }
  }

  // Pieces
  const board = fenToBoard(puzzle.fen);

  // Use a font stack that usually contains chess unicode
  const pieceFont = "Arial Unicode MS, Apple Symbols, Segoe UI Symbol, Noto Sans Symbols2, Arial";

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = board[r][c];
      if (!piece) continue;
      const glyph = PIECE_UNICODE[piece];
      if (!glyph) continue;

      const cx = boardX + c * square + square / 2;
      const cy = boardY + r * square + square / 2;

      // Make pieces readable on both colors: outline trick (draw twice)
      lines.push(
        `<text x="${cx}" y="${cy + 18}" text-anchor="middle" font-size="${square * 0.72}"
           font-family="${pieceFont}" fill="#ffffff" opacity="0.65">
          ${glyph}
        </text>`
      );
      lines.push(
        `<text x="${cx}" y="${cy + 18}" text-anchor="middle" font-size="${square * 0.72}"
           font-family="${pieceFont}" fill="#111">
          ${glyph}
        </text>`
      );
    }
  }

  // Footer
  lines.push(
    `<text x="${pad}" y="${height - 80}" font-size="18" font-family="Arial" fill="#777">
      Generated by chess-tee-generator
    </text>`
  );

  const svg = `
<svg
  width="${width}"
  height="${height}"
  viewBox="0 0 ${width} ${height}"
  xmlns="http://www.w3.org/2000/svg"
>
  <rect x="0" y="0" width="${width}" height="${height}" fill="#ffffff" />
  ${lines.join("\n")}
</svg>
`.trim();

  const resvg = new Resvg(svg, {
    fitTo: { mode: "width", value: width },
  });

  const pngBuffer = resvg.render().asPng();
  const pngBase64 = Buffer.from(pngBuffer).toString("base64");

  return {
    svg,
    png: `data:image/png;base64,${pngBase64}`,
  };
}

